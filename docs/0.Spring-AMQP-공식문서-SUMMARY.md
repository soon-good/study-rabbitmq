# 0. Spring AMQP 공식문서 SUMMARY

Spring AMQP 공식문서의 내용을 요약 및 시나리오기반 테스트&개념 정리

- [docs.spring.io - Spring AMQP](https://docs.spring.io/spring-amqp/docs/current/reference/html/)
- [rabbitmq.com - RabbitMQ Best Practices](https://www.rabbitmq.com/best-practices.html)

<br>

###  TODO

브라우저 내에 여러개의 탭을 띄워놓고 여러가지 자료를 계속 보면서 필요한 자료인지를 읽어보고, 가끔은 또 어떤 용어를 몰라서 찾아보느라 어디까지 봤었는지를 또 까먹고 그러느라 정신이 없다. 그래서 잠깐 메모를 해두는 공간이 필요한데, 여기 저기 주접떨면서 메모해두느니 여기에 **TODO** 들을 모아두는 것이 낫겠다는 생각이 들어 TODO 들을 모아두었다.<br>

<br>

**큐 하나에 대한 최대 허용 메시지 건수**<br>

큐 하나에 허용되는 메시지의 갯수가 7만건이라는 정보를 공식 페이지 어디서 봤었는데 어디에 정리했는지 기억이 안난다.이거 다시 찾아보고 정리해야 한다<br>

**메시지 Delay 시키기**<br>

- `생산자/익스체인지 - 메시지 지연전달 방식(1)` 에 정리해두었다.
- `생산자/익스체인지 - 메시지 지연전달 방식(2)` 는 메시지를 딜레이를 주어 전달할 때 커뮤니티 플러그인을 사용하는 방식을 설명하고 있다. 이 부분은 추후 시스템 개선시에 사용하게 될 방식이 되지 않을까 싶다.

- 큐 - TTL 설정

<br>

**앞으로 더 정리해야 할 것들**<br>

- 생산자 측 - ConnectionFactory - CachingConnectionFactory
- 생산자 측 - 배치 적용된 RabbitTemplate - BatchingRabbitTemplate
- 소비자 측 - MassageListenerContainer Conf
  - batchSize 설정
  - 얼마까지만 받고 있다가 일정량을 받으면 한번에 DB에 insert 하는 방식을 구현할 때 좋은 지침이 될 것 같아 일단은 자료를 스크랩 해두었는데, 일정관리를 꼭 잘해서 적용해봐야 할 것 같다.!!!
- 테스트 시나리오 정하기
  - 2개
    - case 1) 데이터가 전달되면 전달 되는 데로 1초 전의 메시지까지 그대로 뿌려주기
    - case 2) 데이터의 사이즈를 150Byte로 가정해서 5000건의 데이터를 배치 사이즈로 해서 75KB의 데이터를 전송할 경우 평균적으로 몇건의 데이터를 전송하는지 테스트하는 코드
- [Testing Support](https://docs.spring.io/spring-amqp/docs/current/reference/html/#testing)



<br>

### 생산자 측 - 배치(Batch) 메시지 전달방식 (Batching)

테스트 예제와 함께 정리하게 되면서 내용이 길어지게 되어 다른 문서로 분리. 여기에는 뭔가 조금 나만의 깨달음이 생기면 최대한 요약하는 글과 함께 해당 글의 링크를 남겨놓을 예정. 더 이상 TODO 가 안생기게끔 빡시게 달리자!!!!!!!!!!! 아자!!!!!!!!!!!!!!!!!!

<br>

### 생산자 측 - Connection을 다수의 채널로 다중화

Connection 을 논리적인 개념인 채널로 만드는 과정에 대해 정리해야 한다. 아직 자료를 찾긴 했는데 정리는 언제할지 모르겠다. 아직까지는 필요하지는 않다.<br>

- [Channel](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/Channel.html#waitForConfirms(long))
- [rabbitmq.com - Publishers](https://www.rabbitmq.com/publishers.html)

<br>

### 생산자, 소비자 공통 - Connection Pool 관리

Connection Pool 관리기능이다. Channel 들을 여러개 생성해서 하나의 커넥션 내에 여러개의 채널을 관리하는 경우도 있고, 커넥션들을 캐싱하는 경우 역시 있다. 이 개념을 찾아보게 된 계기는 스프링 애플리케이션 내의 rabbitTemplate 생성 로그가 기본으로 7개 정도 생성되는 것을 봐서이다. 캡처는 나중에 올릴거임 <br>

`2021/08/01`<br>

- 이 내용은 현재 2번 정도 공식문서를 정독했는데 어느 정도는 이해가 된 것 같다. 다른 문서로 옮겨서 정리 중이다.<br>
- 개발 초기 단계에서는 동작의 정합성이 잘 되도록 하는 것이 더 중요하기에 지금 당장에 구현하지는 않고 기본 설정을 그대로 사용할 예정이다.  하지만 3주 정도의 목표를 잡고, 하루 2h 정도는 시간을 잡고 커넥션/채널 관련해서 이 내용을 시나리오를 구상해서 적용할 예정이다.

<br>

### 생산자/익스체인지 - 메시지 지연 전달방식(1)

`2021/08/01` : 별도의 테스트 시나리오/캡처와 함께 다른 문서에 따로 정리할 예정이다.<br>

> 메시지를 10분 또는 15분 지연해서 보내야 하는 경우가 있다. 또는 DB에 저장하는 바인딩일 경우는 성능에 지장을 최대한 주지 않기 위해 지연을 주는 경우 역시 있다.<br>

#### 참고자료

- [Scheduling Messages with RabbitMQ](https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq)
- [Delayed Message Exchange - 메시지를 큐로 전송](https://docs.spring.io/spring-amqp/docs/current/reference/html/#delayed-message-exchange)

#### 요약

- 생산자 측) 
  - 메시지를 딜레이시키고 싶을 때는 메시지를 발송할 때 메시지의 헤더에 `x-delay`를 설정해서 메시지를 전송한다. 
  - MessageProperites 에 dealy 값을 세팅해주고 이것을 convertAndSend(..) 시에 담아서 보내는 방식이다.
    - RabbitMQ Java 라이브러리는 MessageProperties 를 제공해준다. 이 MessageProperties클래스 내의 delay 필드에 원하는 Delay 시간을 지정해주면 된다. 단위는 밀리세컨드 단위이다.
    - 이렇게 세팅한 MessageProperties 객체를 `rabbitTemplate.convertAndSend(...)` 에 담아서 보내준다.
  
- Exchange 측) 
  - Exchange 에 delayed 를 true를 준다.
  - `new FanoutExchange().delayed()`

<br>

#### 예제 코드

##### 생산자 측 코드

두 가지 방식이 있다. rabbitTemplate.convertAndSend() 메서드에 MessageProperties 객체를 어떤 방식으로 감싸서 보낼지에 따라 메시지 객체를 생성하는 방식이 달라진다.

- 메시지 빌더 사용
  -  MessageProperties 객체를 세팅하고, MessageBuilder 로 Message 객체를 생성할 때 여기에 MessageBuilder 내의 addProperties() 함수로 프로퍼티를 세팅하는 방식
- 람다를 이용한 방식 
  - rabbitTemplate 의 convertAndSend() 메서드의 가장 마지막에 람다를 전달해준다. 이 람다는 MessagePostProcessor 라는 이름의 인터페이스를 동적 생성한 람다이다.

<br>

**예제 1 ) 메시지 빌더 사용방식**

```java
MessageProperties properties = new MessageProperties();
properties.setDelay(15000);	// 15초 딜레이 설정
template.send(exchange, routingKey,
        MessageBuilder.withBody("foo".getBytes()).andProperties(properties).build());
```

rabbitTemplate 로 데이터를 전송할 때 메시지 빌더로 메시지 프로퍼티를 세팅해서 전달해주고 있는 것을 확인할 수 있다.<br>

<br>

**예제 2) 람다 사용방식**<br>

```java
rabbitTemplate.convertAndSend(exchange, routingKey, "foo", new MessagePostProcessor() {

    @Override
    public Message postProcessMessage(Message message) throws AmqpException {
        message.getMessageProperties().setDelay(15000); // 15초 지연 설정
        return message;
    }

});
```

<br>

##### Exchange 측 코드

Exchange가 delayed 된 데이터를 받을 수 있다는 것을 알려주는 설정을 해주어야 한다.

```java
@Profile("test-rabbitmq-postgresql")
@Configuration
public class MessagePushQueueConfig {
  
	@Bean(name = "messagePushDelayedExchange")
	public FanoutExchange messagePushDelayedExchange(){
		return ExchangeBuilder
			.fanoutExchange("MESSAGE_PUSH_DELAYED_EXCHANGE")
			.delayed()
			.build();
	}
  
  // ...
}
```

<br>

**전체 코드**<br>

```java
@Profile("test-rabbitmq-postgresql")
@Configuration
public class MessagePushQueueConfig {
  // ...
	@Bean(name = "messagePushDelayedQueue")
	public Queue messagePushDelayedQueue(){
		Map arguments = new HashMap();
		arguments.put("x-message-ttl", 1000);	// 1초 전의 데이터까지는 새로 접속한 사람도 모두 받는다.
		final Queue pricePushDelayedQueue = new Queue("messagePushDelayedQueue", false, false, false, arguments);
		return pricePushDelayedQueue;
	}

  // ...
  
	@Bean(name = "messagePushDelayedExchange")
	public FanoutExchange messagePushDelayedExchange(){
		return ExchangeBuilder
			.fanoutExchange("MESSAGE_PUSH_DELAYED_EXCHANGE")
			.delayed()
			.build();
	}
  
  // ...

	@Bean(name = "messagePushDelayedBinding")
	public Binding messagePushDelayedBinding(
		@Qualifier("messagePushDelayedExchange") FanoutExchange exchange,
		@Qualifier("messagePushDelayedQueue") Queue queue
	){
		return BindingBuilder.bind(queue).to(exchange);
	}
}
```

<br>

### 채널/큐 설정 - 메시지 딜레이 방식 (2)

#### 참고자료

- [blog.leocat.kr - 간단 지연 큐 (delayed queue) 설정](https://blog.leocat.kr/notes/2018/07/31/rabbitmq-delayed-queue)
  - Queue0 -> 익스체인지 1 -> 익스체인지 2 -> Queue1  으로 중개하는 방식 까지도 설명하고 있기는 하다.
- [RabbitMQ - Community Plugins](https://www.rabbitmq.com/community-plugins.html)

<br>

#### 요약

위에서 했던 것과는 조금 다른 방식이다. Dead letter 라는 설정을 해주는 방식이다. 이 방식을 사용하려면 RabbitMQ의 [Community Plugin - rabbitmq_delayed_excahnge](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange) 을 활성화 시켜야 한다. 그리고 활성화 시킨 후에 익스체인지 생성시  `x-delayed-type`설정을 지정해서 생성하면 된다.<br>

<br>

만약 AmazonMQ를 관리형으로 사용하고 있다면 사용불가능하지 않나 싶다. 지금은 일단 개발 편의성과 개발일정을 맞춰야 하기에 관리형으로 시작했다. 나중에 설치형으로 전환한다면 한번 또 테스트 해보면서 해야 할 내용이지 않나 싶다.<br>

<br>

### 큐 - TTL 설정

`2021/08/01` : 별도의 테스트 시나리오/캡처와 함께 다른 문서에 따로 정리할 예정이다.<br>

> TTL 설정은 큐에 지정하는 설정이다. 혼동하지 말자. 익스체인지에 하는 설정이 아니다. <br>
>
> (나의 경우는 매번 익스체인지에 TTL을 설정하는 것이라고 자꾸 착각을 했었다.심지어 누가 물어봤을 때 잘못 알고 있는 지식을 전달했었다...)

<br>

#### 참고자료 

- [rabbitmq.com/ttl - Time To Live](https://www.rabbitmq.com/ttl.html) 

<br>

#### 예제코드 

큐 하나에 지연 설정을 해서 TTL 을 걸었는데, 어떤 커넥션 또는 채널은 큐 전체에 설정된 TTL 을 오버라이딩해서 개별 채널에는 다른 TTL을 걸고 싶을 경우는 Message TTL 을 사용한다.<br>

일단 아래 예제는 큐에 Message TTL을 지정하는 방식이다. 이렇게 하면 큐에 접속된 모든 채널은 기본적으로 큐의 MessageTTL 을 따른다. (만약 특정 채널에 다른  TTL을 적용하고 싶다면, 채널이 큐에 접속을 생성할 때 따로 Message TTL 을 지정해서 큐에 접속하게끔 해준다)<br>

##### 큐 설정 (MessagePushQueueConfig.java) 

```java
// ...
@Profile("test-rabbitmq-postgresql")
@Configuration
public class MessagePushQueueConfig {

	@Bean(name = "messagePushQueue")
	public Queue messagePushQueue(){
		Map arguments = new HashMap();
		arguments.put("x-message-ttl", 1000);  // 1초 전의 데이터까지는 새로 접속한 사람도 모두 받는다.
		final Queue pricePushQueue = new Queue("messagePushQueue", false, false, false, arguments);
		return pricePushQueue;
	}
  
  // ... 

	@Bean(name = "messagePushExchange")
	public FanoutExchange messagePushExchange(){
		return ExchangeBuilder
			.fanoutExchange("MESSAGE_PUSH_EXCHANGE")
			.build();
	}

  // ...
  
	@Bean(name = "messagePushBinding")
	public Binding messagePushBinding(
		@Qualifier("messagePushExchange") FanoutExchange exchange,
		@Qualifier("messagePushQueue") Queue queue
	){
		return BindingBuilder.bind(queue).to(exchange);
	}

}
```

<br>

##### 데이터 발송(Push) 로직

```java
package io.study.studyrabbitmqfanout.config.queue.test;

// ... 

@Profile("test-rabbitmq-postgresql")
@Service
public class TestMessagePushProducerService {
	private final RabbitTemplate rabbitTemplate;
	private final FanoutExchange fanoutExchange;
	private final BatchingRabbitTemplate batchingRabbitTemplate;

	public TestMessagePushProducerService(
		@Qualifier("producerRabbitTemplate") final RabbitTemplate rabbitTemplate,
		@Qualifier("batchingRabbitTemplate") final BatchingRabbitTemplate batchingRabbitTemplate,
		@Qualifier("messagePushExchange") final FanoutExchange fanoutExchange
	){
		this.rabbitTemplate = rabbitTemplate;
		this.batchingRabbitTemplate = batchingRabbitTemplate;
		this.fanoutExchange = fanoutExchange;
	}

	@Scheduled(initialDelay = 1000, fixedRate = 500)
	public void sendMessageFixedRate(){
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd HH:mm:ss");
		TestMessageDto msg = TestMessageDto.builder()
			.message("메시지 " + OffsetDateTime.now().format(formatter))
			.build();
		System.out.println("[데이터 전송] " + msg.getMessage());
		rabbitTemplate.convertAndSend(fanoutExchange.getName(), "", msg);
	}
  
  // ...

}
```

<br>

### 소비자측 - 배치 방식 리슨 (정리 필요)

메시지가 특정 갯수만큼 쌓였을 때 리슨함수 내에 정의한 함수가 동작하도록 하는 방식이다. 이렇게 하는 것의 장점은 메시지가 일정 갯수만큼 쌓였을 경우 그때 데이터를 Batch INSERT 하게끔 하는 등의 작업을 할수 있다는 점에서 장점을 가진다.<br>

- [@RabbitListener with Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#receiving-batch)

이렇게 하는 것보다 더 좋은 방식을 찾게 될 수 있다. 일단은 배치방식 리슨에 대해 파악하는 과정을 가져보려 한다.

<br>

### RabbitTemplate 커넥션 관리 - ConnectionFactory

TODO :: 다시 깔끔하게 정리 예정 (다음 주에 추가 예정)



### MessageListenerContainerConfiguration - batchSize 설정

- [Message Listener Container Configuration](https://docs.spring.io/spring-amqp/docs/current/reference/html/#containerAttributes)

<br>

### Resilience: Recovering from Errors and Broker Failures

스프링 클라우드 스택의 여러 스택들과 조화를 이룰수 있도록 이번 개발이 끝나면 또 고도화 하면서 준비하게 될 사항이 되지 않을까 싶다. 아래의  Rtry with Batch Listeners 역시 같은 내용이다.

- [Resilience : Recovering from Errors and Broker Failures](https://docs.spring.io/spring-amqp/docs/current/reference/html/#resilience-recovering-from-errors-and-broker-failures)

<br>

### Retry with Batch Listeners

- [Retry with Batch Listeners](https://docs.spring.io/spring-amqp/docs/current/reference/html/#resilience-recovering-from-errors-and-broker-failures)

이것도 정리해야 한다.

<br>

