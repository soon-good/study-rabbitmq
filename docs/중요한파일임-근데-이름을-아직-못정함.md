아직은 제목을 못정했다. 어떻게 할지 정해야겠다. 지금 정리하는 주제에 대한 세부적인 설정, 내용, 개념들은 다음주 금요일 정도면 어느정도 fix 될 것 같다는 생각이 크다. 단건으로 비교적 은 메시지의 많은 트래픽을 처리하는 것은 래빗엠큐가 구현+운영하기 편해서 쓰는 듯 하다. 하지만, 어느정도 무게감 있으면서 중대형 이상급의 성능은 카프카를 이용하는 듯 해보였다. ([Line 개발팀 블로그](https://engineering.linecorp.com/ko/blog/how-to-use-kafka-in-line-1/))<br>

실제로 노력하는 사람은 항상 스트레스 받고 힘들다. 그런데, 누군가가 알아주지 않는다. 그리고 사회에서는 대부분이 사람이 사람을 이용해먹고 착취하고 이용해먹는 사람이 대부분이다. 가끔 생각할때마다 첫 회사 부장님이 대단하신 분이었구나 하는 생각이 든다. 쉬흔이 가까워서까지 개발과 팀장일까지 모두 하시던 분이었지만, 기획과 개발일정 하나는 합리적으로 계획하셨던 것 같다. 뭔가 사람과 사람 사이의 톤인매너를 지키셨는데 어떤 상황에서도 절대 그걸 깨는걸 본적이 없었다. 그래서 더 무서운 분 같다는 생각을 했었다. 결론은 첫회사 안망했으면 계속 다녔다. 이다.<br>

<br>

#### 공식 자료들

공식 문서 및 약간은 오피셜(?)한 자료들이다.

- [rabbitmq.com - RabbitMQ Best Practices](https://www.rabbitmq.com/best-practices.html)
- [docs.spring.io - Spring AMQP](https://docs.spring.io/spring-amqp/docs/current/reference/html/)

<br>

#### 생산자 측 - 배치(Batch) 메시지 전달방식 (Batching)

배치 처리는 래빗엠큐가 처리하는 것이 아니다. 따라서 생산자 측 코드에서 메시지를 묶어서 보내주거나, 또는 일반적인 RabbitTemplate 이 아닌 BatchingRabbitTemplate 을 사용하면 된다.<br>

배치처럼 메시지를 묶음으로 소비자에게 전달해주기 위해서는 최초에 메시지가 발생할때 아예 메시지를 묶어서 전송해야 한다. 따라서 생산자 측에서 메시지를 생산할 때 초창기부터 묶어서 전송한다.<br>

- [Spring AMQP - Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#template-batching)
- [ProgrammerSought - Spring Boot Message Queue RabbitMQ Getting Started Series Tutorial](https://www.programmersought.com/article/41295475933/)
  - BatchingRabbitTemplate 을 사용하는 방식에 대해서도 설명해주고 있다.

<br>

BatchingRabbitTemplate 은 RabbitTemplate 을 확장한(상속받은) 클래스이다. RabbitTemplate 의 기능을 확장헤서 batch에 관련된 기능이 추가되었다. BatchingRabbitTemplate 은 Spring AMQP 1.4.2 에서부터 추가된 기능이다. <br>

send 또는 convertAndSend () 메서드 내에서 BatchingStrategy 타입의 인스턴스를 전달받아 Batching 방식을 결정지을 수 있다. 타입이나 이런 것은 모두 공식 문서 [Spring AMQP - Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#template-batching) 를 참고하면 될 것 같다.<br>

<br>

**RabbitTemplateConfig.java**<br>

```java
package io.study.studyrabbitmqfanout.config;

// ... 

@Configuration
public class RabbitTemplateConfig {

  // ...
  
	@Bean(name = "mqMessageConverter")
	public MessageConverter mqMessageConverter(){
		return new Jackson2JsonMessageConverter();
	}


	@Bean(name = "batchingRabbitTemplate")
	public BatchingRabbitTemplate batchingRabbitTemplate(
		ConnectionFactory connectionFactory,
		@Qualifier("mqMessageConverter") MessageConverter messageConverter
	){
		int batchSize = 5000; 			// 5천건을 batch size 로 지정
		int bufferLimit = 7500000;	// 메시지 한건이 150Byte 일 경우 150 * 5000 = 750000 Byte, 750KByte
		long timeout = 30000; 			// 타임아웃은 30초
		SimpleBatchingStrategy strategy = new SimpleBatchingStrategy(batchSize, bufferLimit, timeout);
		TaskScheduler taskScheduler = new ConcurrentTaskScheduler();

		final BatchingRabbitTemplate batchingRabbitTemplate = new BatchingRabbitTemplate(connectionFactory, strategy, taskScheduler);
		return batchingRabbitTemplate;
	}

}
```

BatchingStrategy 를 implements 하는 여러개의 클래스중 SimpleBatchingStrategy 를 사용해 인스턴스화 했다.<br>

- `batchSize`
  - batch 안에 포함될 메세지의 갯수이다.
  - 위의 예제에서는 batch로 묶어서 보낼 메시지의 갯수를 5000개로 세팅했다.
- `bufferLimit`
  - 배칭 처리될 메시지의 최대 크기이다. 만약 이 크기를 초월하면 넘치는 사이즈는 잘라서 따로 다시 보낸다.
  - 계산을 진행하기 전에 채팅 메시지 한건의 크기가 최대 150 Byte 일것이라고 가정했다.
- `timeout`
  - 배치에 메시지를 추가하는 새 활동이 없을 때 Partial 배치가 전송되는 시간

<br>

데이터를 전송할 때는 아래와 같이 해주면 된다.

**TestMessagePushProducerService.java**

```java
package io.study.studyrabbitmqfanout.config.queue.test;
// ...
@Profile("test-rabbitmq-postgresql")
@Service
public class TestMessagePushProducerService {
	private final RabbitTemplate rabbitTemplate;
	private final FanoutExchange fanoutExchange;
	private final BatchingRabbitTemplate batchingRabbitTemplate;

	public TestMessagePushProducerService(
		@Qualifier("producerRabbitTemplate") final RabbitTemplate rabbitTemplate,
		@Qualifier("batchingRabbitTemplate") final BatchingRabbitTemplate batchingRabbitTemplate,
		@Qualifier("messagePushExchange") final FanoutExchange fanoutExchange
	){
		this.rabbitTemplate = rabbitTemplate;
		this.batchingRabbitTemplate = batchingRabbitTemplate;
		this.fanoutExchange = fanoutExchange;
	}

  // ...
  
	@Scheduled(initialDelay = 1000, fixedRate = 500)
	public void sendBulkMessage(){
		List<TestMessageDto> list = TestMessageDto.selectSampleMessage(10);
		for(TestMessageDto message : list){
			batchingRabbitTemplate.convertAndSend(fanoutExchange.getName(), "", message);
			// 또는 아래와 같이 구현해줘도 된다.
			// batchingRabbitTemplate.send(fanoutExchange.getName(), "", _message); // message 를 Message 객체내에 감싸서 만든 객체를 넣어줘야 한다.
		}
	}

}
```

<br>

#### 생산자 측 - Connection을 다수의 채널로 다중화

Connection 을 논리적인 개념인 채널로 만드는 과정에 대해 정리해야 한다. 아직 자료를 찾긴 했는데 정리는 언제할지 모르겠다. 아직까지는 필요하지는 않다.<br>

- [Channel](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/Channel.html#waitForConfirms(long))
- [rabbitmq.com - Publishers](https://www.rabbitmq.com/publishers.html)

<br>



#### 생산자, 소비자 공통 - Connection Pool 관리

정리 필요 <br>

<br>

#### 중개자 (익스체인지) 측 - 메시지 지연 전달방식

> 메시지를 10분 또는 15분 지연해서 보내야 하는 경우가 있다. 또는 DB에 저장하는 바인딩일 경우는 성능에 지장을 최대한 주지 않기 위해 지연을 주는 경우 역시 있다.<br>

- [Scheduling Messages with RabbitMQ](https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq)
- [Delayed Message Exchange](https://docs.spring.io/spring-amqp/docs/current/reference/html/#delayed-message-exchange)
- [blog.leocat.kr - 간단 지연 큐 (delayed queue) 설정](https://blog.leocat.kr/notes/2018/07/31/rabbitmq-delayed-queue)
  - 큐 하나에 지연 설정을 해서 TTL 을 걸었는데, 어떤 커넥션 또는 채널은 큐 전체에 설정된 TTL 을 오버라이딩해서 개별 채널에는 다른 TTL을 걸고 싶을 경우는 Message TTL 을 사용한다.

<br>

예제)<br>

```java
package io.study.studyrabbitmqfanout.config.queue;

// ...

@Profile("test-rabbitmq-postgresql")
@Configuration
public class MessagePushQueueConfig {
  
  // ...
  
	@Bean(name = "messagePushDelayedQueue")
	public Queue messagePushDelayedQueue(){
		Map arguments = new HashMap();
		arguments.put("x-dead-letter-exchange", "x2");
		arguments.put("x-message-ttl", 5000L);
		final Queue pricePushDelayedQueue = new Queue("messagePushDelayedQueue", false, false, false, arguments);
		return pricePushDelayedQueue;
	}

  // ...
  
}
```

<br>

#### 소비자측 - 배치방식 리슨

- [@RabbitListener with Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#receiving-batch)

<br>

#### RabbitMQ 소켓 ConnectionFactory 커스터마이징

커넥션 풀 관련 설정을 할 때 자주 나오는 클래스들이 객체 생성에 관련된 것이어서 그런지  ConnectionFactory 또는 Builder 같은 이름이 붙어있는 것 같다. 

- [Connection and Resource Management](https://docs.spring.io/spring-amqp/docs/current/reference/html/#connections)

<br>

#### MessageListenerContainerConfiguration 내의 batchSize 설정

- [Message Listener Container Configuration](https://docs.spring.io/spring-amqp/docs/current/reference/html/#containerAttributes)

<br>

#### Resilience: Recovering from Errors and Broker Failures

- [Resilience : Recovering from Errors and Broker Failures](https://docs.spring.io/spring-amqp/docs/current/reference/html/#resilience-recovering-from-errors-and-broker-failures)

<br>

#### Retry with Batch Listeners

- [Retry with Batch Listeners](https://docs.spring.io/spring-amqp/docs/current/reference/html/#resilience-recovering-from-errors-and-broker-failures)

이것도 정리해야 한다.

<br>