###  TODO

브라우저 내에 여러개의 탭을 띄워놓고 여러가지 자료를 계속 보면서 필요한 자료인지를 읽어보고, 가끔은 또 어떤 용어를 몰라서 찾아보느라 어디까지 봤었는지를 또 까먹고 그러느라 정신이 없다. 그래서 잠깐 메모를 해두는 공간이 필요한데, 여기 저기 주접떨면서 메모해두느니 여기에 **TODO** 들을 모아두는 것이 낫겠다는 생각이 들어 TODO 들을 모아두었다.<br>

<br>

**큐 하나에 대한 최대 허용 메시지 건수**<br>

큐 하나에 허용되는 메시지의 갯수가 7만건이라는 정보를 공식 페이지 어디서 봤었는데 어디에 정리했는지 기억이 안난다.이거 다시 찾아보고 정리해야 한다<br>

**메시지 Delay 시키기**<br>

- `생산자/익스체인지 - 메시지 지연전달 방식(1)` 에 정리해두었다.
- `생산자/익스체인지 - 메시지 지연전달 방식(2)` 는 메시지를 딜레이를 주어 전달할 때 커뮤니티 플러그인을 사용하는 방식을 설명하고 있다. 이 부분은 추후 시스템 개선시에 사용하게 될 방식이 되지 않을까 싶다.

- 큐 - TTL 설정

<br>

**앞으로 더 정리해야 할 것들**<br>

- 생산자 측 - ConnectionFactory - CachingConnectionFactory
- 생산자 측 - 배치 적용된 RabbitTemplate - BatchingRabbitTemplate
- 소비자 측 - MassageListenerContainer Conf
  - batchSize 설정
  - 얼마까지만 받고 있다가 일정량을 받으면 한번에 DB에 insert 하는 방식을 구현할 때 좋은 지침이 될 것 같아 일단은 자료를 스크랩 해두었는데, 일정관리를 꼭 잘해서 적용해봐야 할 것 같다.!!!
- 테스트 시나리오 정하기
  - 2개
    - case 1) 데이터가 전달되면 전달 되는 데로 1초 전의 메시지까지 그대로 뿌려주기
    - case 2) 데이터의 사이즈를 150Byte로 가정해서 5000건의 데이터를 배치 사이즈로 해서 75KB의 데이터를 전송할 경우 평균적으로 몇건의 데이터를 전송하는지 테스트하는 코드
- [Testing Support](https://docs.spring.io/spring-amqp/docs/current/reference/html/#testing)



### 공식 자료들

공식 문서 및 약간은 오피셜(?)한 자료들이다.

- [rabbitmq.com - RabbitMQ Best Practices](https://www.rabbitmq.com/best-practices.html)
- [docs.spring.io - Spring AMQP](https://docs.spring.io/spring-amqp/docs/current/reference/html/)

<br>

### 생산자 측 - 배치(Batch) 메시지 전달방식 (Batching)

배치 처리는 래빗엠큐가 처리하는 것이 아니다. 따라서 생산자 측 코드에서 메시지를 묶어서 보내주거나, 또는 일반적인 RabbitTemplate 이 아닌 BatchingRabbitTemplate 을 사용하면 된다.<br>

배치처럼 메시지를 묶음으로 소비자에게 전달해주기 위해서는 최초에 메시지가 발생할때 아예 메시지를 묶어서 전송해야 한다. 따라서 생산자 측에서 메시지를 생산할 때 초창기부터 묶어서 전송한다.<br>

- [Spring AMQP - Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#template-batching)
- [ProgrammerSought - Spring Boot Message Queue RabbitMQ Getting Started Series Tutorial](https://www.programmersought.com/article/41295475933/)
  - BatchingRabbitTemplate 을 사용하는 방식에 대해서도 설명해주고 있다.

<br>

BatchingRabbitTemplate 은 RabbitTemplate 을 확장한(상속받은) 클래스이다. RabbitTemplate 의 기능을 확장헤서 batch에 관련된 기능이 추가되었다. BatchingRabbitTemplate 은 Spring AMQP 1.4.2 에서부터 추가된 기능이다. <br>

send 또는 convertAndSend () 메서드 내에서 BatchingStrategy 타입의 인스턴스를 전달받아 Batching 방식을 결정지을 수 있다. 타입이나 이런 것은 모두 공식 문서 [Spring AMQP - Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#template-batching) 를 참고하면 될 것 같다.<br>

<br>

**RabbitTemplateConfig.java**<br>

> 참고 : [실습 예제 URL](https://github.com/gosgjung/study-rabbitmq/tree/develop/study-rabbitmq-fanout/src/main/java/io/study/studyrabbitmqfanout/config)

```java
package io.study.studyrabbitmqfanout.config;

// ... 

@Configuration
public class RabbitTemplateConfig {

  // ...
  
	@Bean(name = "mqMessageConverter")
	public MessageConverter mqMessageConverter(){
		return new Jackson2JsonMessageConverter();
	}


	@Bean(name = "batchingRabbitTemplate")
	public BatchingRabbitTemplate batchingRabbitTemplate(
		ConnectionFactory connectionFactory,
		@Qualifier("mqMessageConverter") MessageConverter messageConverter
	){
		int batchSize = 5000; 			// 5천건을 batch size 로 지정
		int bufferLimit = 7500000;	// 메시지 한건이 150Byte 일 경우 150 * 5000 = 750000 Byte, 750KByte
		long timeout = 30000; 			// 타임아웃은 30초
		SimpleBatchingStrategy strategy = new SimpleBatchingStrategy(batchSize, bufferLimit, timeout);
		TaskScheduler taskScheduler = new ConcurrentTaskScheduler();

		final BatchingRabbitTemplate batchingRabbitTemplate = new BatchingRabbitTemplate(connectionFactory, strategy, taskScheduler);
		return batchingRabbitTemplate;
	}

}
```

BatchingStrategy 를 implements 하는 여러개의 클래스중 SimpleBatchingStrategy 를 사용해 인스턴스화 했다.<br>

- `batchSize`
  - batch 안에 포함될 메세지의 갯수이다.
  - 위의 예제에서는 batch로 묶어서 보낼 메시지의 갯수를 5000개로 세팅했다.
- `bufferLimit`
  - 배칭 처리될 메시지의 최대 크기이다. 만약 이 크기를 초월하면 넘치는 사이즈는 잘라서 따로 다시 보낸다.
  - 계산을 진행하기 전에 채팅 메시지 한건의 크기가 최대 150 Byte 일것이라고 가정했다.
- `timeout`
  - 배치에 메시지를 추가하는 새 활동이 없을 때 Partial 배치가 전송되는 시간

<br>

데이터를 전송할 때는 아래와 같이 해주면 된다.

**TestMessagePushProducerService.java**<br>

> 참고 : [실습 예제 URL](https://github.com/gosgjung/study-rabbitmq/tree/develop/study-rabbitmq-fanout/src/main/java/io/study/studyrabbitmqfanout/config)

```java
package io.study.studyrabbitmqfanout.config.queue.test;
// ...
@Profile("test-rabbitmq-postgresql")
@Service
public class TestMessagePushProducerService {
	private final RabbitTemplate rabbitTemplate;
	private final FanoutExchange fanoutExchange;
	private final BatchingRabbitTemplate batchingRabbitTemplate;

	public TestMessagePushProducerService(
		@Qualifier("producerRabbitTemplate") final RabbitTemplate rabbitTemplate,
		@Qualifier("batchingRabbitTemplate") final BatchingRabbitTemplate batchingRabbitTemplate,
		@Qualifier("messagePushExchange") final FanoutExchange fanoutExchange
	){
		this.rabbitTemplate = rabbitTemplate;
		this.batchingRabbitTemplate = batchingRabbitTemplate;
		this.fanoutExchange = fanoutExchange;
	}

  // ...
  
	@Scheduled(initialDelay = 1000, fixedRate = 500)
	public void sendBulkMessage(){
		List<TestMessageDto> list = TestMessageDto.selectSampleMessage(10);
		for(TestMessageDto message : list){
			batchingRabbitTemplate.convertAndSend(fanoutExchange.getName(), "", message);
			// 또는 아래와 같이 구현해줘도 된다.
			// batchingRabbitTemplate.send(fanoutExchange.getName(), "", _message); // message 를 Message 객체내에 감싸서 만든 객체를 넣어줘야 한다.
		}
	}

}
```

<br>

### 생산자 측 - Connection을 다수의 채널로 다중화

Connection 을 논리적인 개념인 채널로 만드는 과정에 대해 정리해야 한다. 아직 자료를 찾긴 했는데 정리는 언제할지 모르겠다. 아직까지는 필요하지는 않다.<br>

- [Channel](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/Channel.html#waitForConfirms(long))
- [rabbitmq.com - Publishers](https://www.rabbitmq.com/publishers.html)

<br>

### 생산자, 소비자 공통 - Connection Pool 관리

스프링 쪽 보통은 ConnectionFactory 라는 클래스들이 자주 보였던 것 같다. Spring AMQP(=래빗엠큐에만 한정된 것이 아니다.)에서도 ConnectionFactory 와 같은 클래스로 Connection 객체를 생성하는 것에 대한 표준을 잡아놓았다. 해당 내용

<br>

### 생산자/익스체인지 - 메시지 지연 전달방식(1)

> 메시지를 10분 또는 15분 지연해서 보내야 하는 경우가 있다. 또는 DB에 저장하는 바인딩일 경우는 성능에 지장을 최대한 주지 않기 위해 지연을 주는 경우 역시 있다.<br>

#### 참고자료

- [Scheduling Messages with RabbitMQ](https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq)
- [Delayed Message Exchange - 메시지를 큐로 전송](https://docs.spring.io/spring-amqp/docs/current/reference/html/#delayed-message-exchange)

#### 요약

- 생산자 측) 
  - 메시지를 딜레이시키고 싶을 때는 메시지를 발송할 때 메시지의 헤더에 `x-delay`를 설정해서 메시지를 전송한다. 
  - MessageProperites 에 dealy 값을 세팅해주고 이것을 convertAndSend(..) 시에 담아서 보내는 방식이다.
    - RabbitMQ Java 라이브러리는 MessageProperties 를 제공해준다. 이 MessageProperties클래스 내의 delay 필드에 원하는 Delay 시간을 지정해주면 된다. 단위는 밀리세컨드 단위이다.
    - 이렇게 세팅한 MessageProperties 객체를 `rabbitTemplate.convertAndSend(...)` 에 담아서 보내준다.
  
- Exchange 측) 
  - Exchange 에 delayed 를 true를 준다.
  - `new FanoutExchange().delayed()`

#### 예제 코드

##### 생산자 측 코드

두 가지 방식이 있다. rabbitTemplate.convertAndSend() 메서드에 MessageProperties 객체를 어떤 방식으로 감싸서 보낼지에 따라 메시지 객체를 생성하는 방식이 달라진다.

- 메시지 빌더 사용
  -  MessageProperties 객체를 세팅하고, MessageBuilder 로 Message 객체를 생성할 때 여기에 MessageBuilder 내의 addProperties() 함수로 프로퍼티를 세팅하는 방식
- 람다를 이용한 방식 
  - rabbitTemplate 의 convertAndSend() 메서드의 가장 마지막에 람다를 전달해준다. 이 람다는 MessagePostProcessor 라는 이름의 인터페이스를 동적 생성한 람다이다.

<br>

**예제 1 ) 메시지 빌더 사용방식**

```java
MessageProperties properties = new MessageProperties();
properties.setDelay(15000);	// 15초 딜레이 설정
template.send(exchange, routingKey,
        MessageBuilder.withBody("foo".getBytes()).andProperties(properties).build());
```

rabbitTemplate 로 데이터를 전송할 때 메시지 빌더로 메시지 프로퍼티를 세팅해서 전달해주고 있는 것을 확인할 수 있다.<br>

<br>

**예제 2) 람다 사용방식**<br>

```java
rabbitTemplate.convertAndSend(exchange, routingKey, "foo", new MessagePostProcessor() {

    @Override
    public Message postProcessMessage(Message message) throws AmqpException {
        message.getMessageProperties().setDelay(15000); // 15초 지연 설정
        return message;
    }

});
```

<br>

##### Exchange 측 코드

Exchange가 delayed 된 데이터를 받을 수 있다는 것을 알려주는 설정을 해주어야 한다.

```java
@Profile("test-rabbitmq-postgresql")
@Configuration
public class MessagePushQueueConfig {
  
	@Bean(name = "messagePushDelayedExchange")
	public FanoutExchange messagePushDelayedExchange(){
		return ExchangeBuilder
			.fanoutExchange("MESSAGE_PUSH_DELAYED_EXCHANGE")
			.delayed()
			.build();
	}
  
  // ...
}
```

<br>

**전체 코드**<br>

```java
@Profile("test-rabbitmq-postgresql")
@Configuration
public class MessagePushQueueConfig {
  // ...
	@Bean(name = "messagePushDelayedQueue")
	public Queue messagePushDelayedQueue(){
		Map arguments = new HashMap();
		arguments.put("x-message-ttl", 1000);	// 1초 전의 데이터까지는 새로 접속한 사람도 모두 받는다.
		final Queue pricePushDelayedQueue = new Queue("messagePushDelayedQueue", false, false, false, arguments);
		return pricePushDelayedQueue;
	}

  // ...
  
	@Bean(name = "messagePushDelayedExchange")
	public FanoutExchange messagePushDelayedExchange(){
		return ExchangeBuilder
			.fanoutExchange("MESSAGE_PUSH_DELAYED_EXCHANGE")
			.delayed()
			.build();
	}
  
  // ...

	@Bean(name = "messagePushDelayedBinding")
	public Binding messagePushDelayedBinding(
		@Qualifier("messagePushDelayedExchange") FanoutExchange exchange,
		@Qualifier("messagePushDelayedQueue") Queue queue
	){
		return BindingBuilder.bind(queue).to(exchange);
	}
}
```

<br>

### 채널/큐 설정 - 메시지 딜레이 방식 (2)

#### 참고자료

- [blog.leocat.kr - 간단 지연 큐 (delayed queue) 설정](https://blog.leocat.kr/notes/2018/07/31/rabbitmq-delayed-queue)
  - Queue0 -> 익스체인지 1 -> 익스체인지 2 -> Queue1  으로 중개하는 방식 까지도 설명하고 있기는 하다.
- [RabbitMQ - Community Plugins](https://www.rabbitmq.com/community-plugins.html)

<br>

#### 요약

위에서 했던 것과는 조금 다른 방식이다. Dead letter 라는 설정을 해주는 방식이다. 이 방식을 사용하려면 RabbitMQ의 [Community Plugin - rabbitmq_delayed_excahnge](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange) 을 활성화 시켜야 한다. 그리고 활성화 시킨 후에 익스체인지 생성시  `x-delayed-type`설정을 지정해서 생성하면 된다.<br>

<br>

만약 AmazonMQ를 관리형으로 사용하고 있다면 사용불가능하지 않나 싶다. 지금은 일단 개발 편의성과 개발일정을 맞춰야 하기에 관리형으로 시작했다. 나중에 설치형으로 전환한다면 한번 또 테스트 해보면서 해야 할 내용이지 않나 싶다.<br>

<br>

### 큐 - TTL 설정

> TTL 설정은 큐에 지정하는 설정이다. 혼동하지 말자. 익스체인지에 하는 설정이 아니다. <br>
>
> (나의 경우는 매번 익스체인지에 TTL을 설정하는 것이라고 자꾸 착각을 했었다.심지어 누가 물어봤을 때 잘못 알고 있는 지식을 전달했었다...)

<br>

#### 참고자료 

- [rabbitmq.com/ttl - Time To Live](https://www.rabbitmq.com/ttl.html) 

<br>

#### 예제코드 

큐 하나에 지연 설정을 해서 TTL 을 걸었는데, 어떤 커넥션 또는 채널은 큐 전체에 설정된 TTL 을 오버라이딩해서 개별 채널에는 다른 TTL을 걸고 싶을 경우는 Message TTL 을 사용한다.<br>

일단 아래 예제는 큐에 Message TTL을 지정하는 방식이다. 이렇게 하면 큐에 접속된 모든 채널은 기본적으로 큐의 MessageTTL 을 따른다. (만약 특정 채널에 다른  TTL을 적용하고 싶다면, 채널이 큐에 접속을 생성할 때 따로 Message TTL 을 지정해서 큐에 접속하게끔 해준다)<br>

##### 큐 설정 (MessagePushQueueConfig.java) 

```java
// ...
@Profile("test-rabbitmq-postgresql")
@Configuration
public class MessagePushQueueConfig {

	@Bean(name = "messagePushQueue")
	public Queue messagePushQueue(){
		Map arguments = new HashMap();
		arguments.put("x-message-ttl", 1000);  // 1초 전의 데이터까지는 새로 접속한 사람도 모두 받는다.
		final Queue pricePushQueue = new Queue("messagePushQueue", false, false, false, arguments);
		return pricePushQueue;
	}
  
  // ... 

	@Bean(name = "messagePushExchange")
	public FanoutExchange messagePushExchange(){
		return ExchangeBuilder
			.fanoutExchange("MESSAGE_PUSH_EXCHANGE")
			.build();
	}

  // ...
  
	@Bean(name = "messagePushBinding")
	public Binding messagePushBinding(
		@Qualifier("messagePushExchange") FanoutExchange exchange,
		@Qualifier("messagePushQueue") Queue queue
	){
		return BindingBuilder.bind(queue).to(exchange);
	}

}
```

<br>

##### 데이터 발송(Push) 로직

```java
package io.study.studyrabbitmqfanout.config.queue.test;

// ... 

@Profile("test-rabbitmq-postgresql")
@Service
public class TestMessagePushProducerService {
	private final RabbitTemplate rabbitTemplate;
	private final FanoutExchange fanoutExchange;
	private final BatchingRabbitTemplate batchingRabbitTemplate;

	public TestMessagePushProducerService(
		@Qualifier("producerRabbitTemplate") final RabbitTemplate rabbitTemplate,
		@Qualifier("batchingRabbitTemplate") final BatchingRabbitTemplate batchingRabbitTemplate,
		@Qualifier("messagePushExchange") final FanoutExchange fanoutExchange
	){
		this.rabbitTemplate = rabbitTemplate;
		this.batchingRabbitTemplate = batchingRabbitTemplate;
		this.fanoutExchange = fanoutExchange;
	}

	@Scheduled(initialDelay = 1000, fixedRate = 500)
	public void sendMessageFixedRate(){
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd HH:mm:ss");
		TestMessageDto msg = TestMessageDto.builder()
			.message("메시지 " + OffsetDateTime.now().format(formatter))
			.build();
		System.out.println("[데이터 전송] " + msg.getMessage());
		rabbitTemplate.convertAndSend(fanoutExchange.getName(), "", msg);
	}
  
  // ...

}
```

<br>

### 소비자측 - 배치 방식 리슨 (정리 필요)

메시지가 특정 갯수만큼 쌓였을 때 리슨함수 내에 정의한 함수가 동작하도록 하는 방식이다. 이렇게 하는 것의 장점은 메시지가 일정 갯수만큼 쌓였을 경우 그때 데이터를 Batch INSERT 하게끔 하는 등의 작업을 할수 있다는 점에서 장점을 가진다.<br>

- [@RabbitListener with Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#receiving-batch)

이렇게 하는 것보다 더 좋은 방식을 찾게 될 수 있다. 일단은 배치방식 리슨에 대해 파악하는 과정을 가져보려 한다.

<br>

### RabbitTemplate 커넥션 관리 - ConnectionFactory

TODO :: 다시 깔끔하게 정리 예정 (다음 주에 추가 예정)



### MessageListenerContainerConfiguration - batchSize 설정

- [Message Listener Container Configuration](https://docs.spring.io/spring-amqp/docs/current/reference/html/#containerAttributes)

<br>

### Resilience: Recovering from Errors and Broker Failures

스프링 클라우드 스택의 여러 스택들과 조화를 이룰수 있도록 이번 개발이 끝나면 또 고도화 하면서 준비하게 될 사항이 되지 않을까 싶다. 아래의  Rtry with Batch Listeners 역시 같은 내용이다.

- [Resilience : Recovering from Errors and Broker Failures](https://docs.spring.io/spring-amqp/docs/current/reference/html/#resilience-recovering-from-errors-and-broker-failures)

<br>

### Retry with Batch Listeners

- [Retry with Batch Listeners](https://docs.spring.io/spring-amqp/docs/current/reference/html/#resilience-recovering-from-errors-and-broker-failures)

이것도 정리해야 한다.

<br>

