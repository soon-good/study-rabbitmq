다음주 중으로 뭐가 됐든 보일것 같다. 기자가 된 기분이다. 취재하는 기분. 이 참에 일 때려치고 40대부터는 기자나 해볼까? 하는 헛된 상상한번 해봄.<br>

#### 공식 자료들

공식 문서 및 약간은 오피셜(?)한 자료들이다.

- [rabbitmq.com - RabbitMQ Best Practices](https://www.rabbitmq.com/best-practices.html)
- [docs.spring.io - Spring AMQP](https://docs.spring.io/spring-amqp/docs/current/reference/html/)

<br>

#### 생산자 측 - 배치(Batch) 메시지 전달방식 (Batching)

배치 처리는 래빗엠큐가 처리하는 것이 아니다. 따라서 생산자 측 코드에서 메시지를 묶어서 보내주거나, 또는 일반적인 RabbitTemplate 이 아닌 BatchingRabbitTemplate 을 사용하면 된다.<br>

배치처럼 메시지를 묶음으로 소비자에게 전달해주기 위해서는 최초에 메시지가 발생할때 아예 메시지를 묶어서 전송해야 한다. 따라서 생산자 측에서 메시지를 생산할 때 초창기부터 묶어서 전송한다.<br>

- [Spring AMQP - Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#template-batching)
- [ProgrammerSought - Spring Boot Message Queue RabbitMQ Getting Started Series Tutorial](https://www.programmersought.com/article/41295475933/)
  - BatchingRabbitTemplate 을 사용하는 방식에 대해서도 설명해주고 있다.

<br>

BatchingRabbitTemplate 은 RabbitTemplate 을 확장한(상속받은) 클래스이다. RabbitTemplate 의 기능을 확장헤서 batch에 관련된 기능이 추가되었다. BatchingRabbitTemplate 은 Spring AMQP 1.4.2 에서부터 추가된 기능이다. <br>

send 또는 convertAndSend () 메서드 내에서 BatchingStrategy 타입의 인스턴스를 전달받아 Batching 방식을 결정지을 수 있다. 타입이나 이런 것은 모두 공식 문서 [Spring AMQP - Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#template-batching) 를 참고하면 될 것 같다.<br>

<br>

**RabbitTemplateConfig.java**<br>

> 참고 : [실습 예제 URL](https://github.com/gosgjung/study-rabbitmq/tree/develop/study-rabbitmq-fanout/src/main/java/io/study/studyrabbitmqfanout/config)

```java
package io.study.studyrabbitmqfanout.config;

// ... 

@Configuration
public class RabbitTemplateConfig {

  // ...
  
	@Bean(name = "mqMessageConverter")
	public MessageConverter mqMessageConverter(){
		return new Jackson2JsonMessageConverter();
	}


	@Bean(name = "batchingRabbitTemplate")
	public BatchingRabbitTemplate batchingRabbitTemplate(
		ConnectionFactory connectionFactory,
		@Qualifier("mqMessageConverter") MessageConverter messageConverter
	){
		int batchSize = 5000; 			// 5천건을 batch size 로 지정
		int bufferLimit = 7500000;	// 메시지 한건이 150Byte 일 경우 150 * 5000 = 750000 Byte, 750KByte
		long timeout = 30000; 			// 타임아웃은 30초
		SimpleBatchingStrategy strategy = new SimpleBatchingStrategy(batchSize, bufferLimit, timeout);
		TaskScheduler taskScheduler = new ConcurrentTaskScheduler();

		final BatchingRabbitTemplate batchingRabbitTemplate = new BatchingRabbitTemplate(connectionFactory, strategy, taskScheduler);
		return batchingRabbitTemplate;
	}

}
```

BatchingStrategy 를 implements 하는 여러개의 클래스중 SimpleBatchingStrategy 를 사용해 인스턴스화 했다.<br>

- `batchSize`
  - batch 안에 포함될 메세지의 갯수이다.
  - 위의 예제에서는 batch로 묶어서 보낼 메시지의 갯수를 5000개로 세팅했다.
- `bufferLimit`
  - 배칭 처리될 메시지의 최대 크기이다. 만약 이 크기를 초월하면 넘치는 사이즈는 잘라서 따로 다시 보낸다.
  - 계산을 진행하기 전에 채팅 메시지 한건의 크기가 최대 150 Byte 일것이라고 가정했다.
- `timeout`
  - 배치에 메시지를 추가하는 새 활동이 없을 때 Partial 배치가 전송되는 시간

<br>

데이터를 전송할 때는 아래와 같이 해주면 된다.

**TestMessagePushProducerService.java**<br>

> 참고 : [실습 예제 URL](https://github.com/gosgjung/study-rabbitmq/tree/develop/study-rabbitmq-fanout/src/main/java/io/study/studyrabbitmqfanout/config)

```java
package io.study.studyrabbitmqfanout.config.queue.test;
// ...
@Profile("test-rabbitmq-postgresql")
@Service
public class TestMessagePushProducerService {
	private final RabbitTemplate rabbitTemplate;
	private final FanoutExchange fanoutExchange;
	private final BatchingRabbitTemplate batchingRabbitTemplate;

	public TestMessagePushProducerService(
		@Qualifier("producerRabbitTemplate") final RabbitTemplate rabbitTemplate,
		@Qualifier("batchingRabbitTemplate") final BatchingRabbitTemplate batchingRabbitTemplate,
		@Qualifier("messagePushExchange") final FanoutExchange fanoutExchange
	){
		this.rabbitTemplate = rabbitTemplate;
		this.batchingRabbitTemplate = batchingRabbitTemplate;
		this.fanoutExchange = fanoutExchange;
	}

  // ...
  
	@Scheduled(initialDelay = 1000, fixedRate = 500)
	public void sendBulkMessage(){
		List<TestMessageDto> list = TestMessageDto.selectSampleMessage(10);
		for(TestMessageDto message : list){
			batchingRabbitTemplate.convertAndSend(fanoutExchange.getName(), "", message);
			// 또는 아래와 같이 구현해줘도 된다.
			// batchingRabbitTemplate.send(fanoutExchange.getName(), "", _message); // message 를 Message 객체내에 감싸서 만든 객체를 넣어줘야 한다.
		}
	}

}
```

<br>

#### 생산자 측 - Connection을 다수의 채널로 다중화

Connection 을 논리적인 개념인 채널로 만드는 과정에 대해 정리해야 한다. 아직 자료를 찾긴 했는데 정리는 언제할지 모르겠다. 아직까지는 필요하지는 않다.<br>

- [Channel](https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/Channel.html#waitForConfirms(long))
- [rabbitmq.com - Publishers](https://www.rabbitmq.com/publishers.html)

<br>

#### 생산자, 소비자 공통 - Connection Pool 관리

스프링 쪽 보통은 ConnectionFactory 라는 클래스들이 자주 보였던 것 같다. Spring AMQP(=래빗엠큐에만 한정된 것이 아니다.)에서도 ConnectionFactory 와 같은 클래스로 Connection 객체를 생성하는 것에 대한 표준을 잡아놓았다. 해당 내용

<br>

#### 중개자 (익스체인지) 측 - 메시지 지연 전달방식

> 메시지를 10분 또는 15분 지연해서 보내야 하는 경우가 있다. 또는 DB에 저장하는 바인딩일 경우는 성능에 지장을 최대한 주지 않기 위해 지연을 주는 경우 역시 있다.<br>

- [Scheduling Messages with RabbitMQ](https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq)
- [Delayed Message Exchange](https://docs.spring.io/spring-amqp/docs/current/reference/html/#delayed-message-exchange)
- [blog.leocat.kr - 간단 지연 큐 (delayed queue) 설정](https://blog.leocat.kr/notes/2018/07/31/rabbitmq-delayed-queue)
  - 큐 하나에 지연 설정을 해서 TTL 을 걸었는데, 어떤 커넥션 또는 채널은 큐 전체에 설정된 TTL 을 오버라이딩해서 개별 채널에는 다른 TTL을 걸고 싶을 경우는 Message TTL 을 사용한다.

<br>

예제 - [실습 예제 URL](https://github.com/gosgjung/study-rabbitmq/tree/develop/study-rabbitmq-fanout/src/main/java/io/study/studyrabbitmqfanout/config))<br>

```java
package io.study.studyrabbitmqfanout.config.queue;

// ...

@Profile("test-rabbitmq-postgresql")
@Configuration
public class MessagePushQueueConfig {
  
  // ...
  
	@Bean(name = "messagePushDelayedQueue")
	public Queue messagePushDelayedQueue(){
		Map arguments = new HashMap();
		arguments.put("x-dead-letter-exchange", "x2");
		arguments.put("x-message-ttl", 5000L);
		final Queue pricePushDelayedQueue = new Queue("messagePushDelayedQueue", false, false, false, arguments);
		return pricePushDelayedQueue;
	}

  // ...
  
}
```

<br>

#### 소비자측 - 배치방식 리슨

메시지가 특정 갯수만큼 쌓였을 때 리슨함수 내에 정의한 함수가 동작하도록 하는 방식이다.

- [@RabbitListener with Batching](https://docs.spring.io/spring-amqp/docs/current/reference/html/#receiving-batch)

<br>

#### RabbitMQ 소켓 ConnectionFactory 커스터마이징

커넥션 풀 관련 설정을 할 때 자주 나오는 클래스들이 객체 생성에 관련된 것이어서 그런지  ConnectionFactory 또는 Builder 같은 이름이 붙어있는 것 같다. 이번에 정리하는 내용은 ConnectionFactory 에 관련된 내용이다.<br>

- [Connection and Resource Management](https://docs.spring.io/spring-amqp/docs/current/reference/html/#connections)

<br>

Spring RabbitMQ 를 사용할 때 지원되는 ConnectionFactory 관련해서 지원되는 클래스들은 아래의 3가지이다.

- `PooledChannelConnectionFactory`
  - 대부분의 경우에는 `PooledChannelConnectionFactory` 가 사용된다.
  - Spring AMQP를 프로젝트에 의존성으로 추가하면 Apache 의 `commons-pool2` 가 클래스패스에 포함된다.
  - 2개의 풀을 사용한다. 풀은 채널들을 담아두는 역할을 한다. 이 두 개의 풀은 아래와 같은 종류들이 있다.
    - 트랜잭션 처리가 필요한 채널(Transactional Channel)을 관리하는 풀
    - 트랜잭션이 아닌 채널(Non Transactional Channel)을 관리하는 풀

- `ThreadChannelConnectionFactory`
  - 엄격한 메시지 순서를 보장하고자 할때 사용된다.
  - 단일 커넥션을 사용하고, 두개의 `ThreadLocal` 을 사용한다.
    - 참고) [자바캔 - ThreadLocal](https://javacan.tistory.com/entry/ThreadLocalUsage) , [ThreadLocal 이란?](https://yeonbot.github.io/java/ThreadLocal/) 
  - 두개의 ThreadLocal 을 사용하는데, 이 두개의 ThreadLocal 은 아래와 같은 종류들이 있다.
    - 트랜잭션 처리가 필요한 채널들에 사용되는 ThreadLocal
    - 트랜잭션 처리가 필요하지 않은 채널들에 사용되는 ThreadLocal
  - [Scoped Operation](https://docs.spring.io/spring-amqp/docs/current/reference/html/#scoped-operations) 이라는 것이 있는데, 이 Scoped Operation 없이 메시지 순서를 보장할 경우에 사용된다.
- `CachingConnectionFactory`
  - 연관성 있는 Publisher를 확인(Confirmation)하고자 할 때 사용한다.
  - `CacheMode` 로 여러 연결을 열고자 할 때 사용한다.
  - 기본 설정으로 단일 커넥션 프록시를 생성하고, 애플리케이션에서 이것을 공유한다.
  - 구현체 CachingConnectionFactory 로 채널들을 캐싱할 수 있다.
  - 채널들에 대해서 분리된 캐시들을 유지하고 관리한다.(트랜잭션 성격의 채널인지와는 무관하다.)
  - 1.3 버전부터 CacheConnectionFactory를 설정하는 것으로 커넥션, 채널 모두를 캐싱할 수 잇게 되었다.
    - createConnection() 메서드를 사용하면 새로운 커넥션을 생성한다.
    - 이때 커넥션 안에 생성된 채널들 역시 캐싱된다.
  - 1.55 버전부터 `connectionLimit` 이라는 새로운 속성이 생겼다. connectionLimit 은 허용되는 커넥션의 갯수를 제한한다. 이 connectionLimit 을 초과하면, channelCheckoutTimeLimit  필드를 사용해서 체크하는 작업이 수행된다. 이 때 idle 된 커넥션이 생기기를 기다리는데, channelCheckoutTimeLimit 필드를 사용하게 된다. 만약 이 시간이 초과되면  AmqpTimeoutException 이 발생된다.
  - 커넥션이 캐싱되도록 하려면 cacheMode 필드를 `CacheMode.CONNECTION` 으로 세팅해주면 된다.
  - cacheMode 필드를 CacheMode.CONNECTION 으로 설정하면, RabbitMQ 의 queue 및 기타 리소스에 대한 기본 선언들이 무효화 되어 직접 설정을 해야 한다.
  - CacheMode.CONNECTION 을 설정해서 커넥션을 캐싱하게 되면, `amqp-client` 라이브러리가 각 커넥션에 대해 고정된 스레드 풀(fixed thread pool)을 생성한다. 디폴트로 내부에 지정된 thread pool 내에 포함될 수 있는 스레드의 갯수는 `Runtime.getRuntime().availableProcessors() * 2` 이다.
  - 커넥션의 갯수가 많을 때는 커스텀  executor 를 CachingCononectionFactory 내에 세팅해주는 것을 고려해 봐야 한다. 이렇게 하면  executor 로 모든 커넥션들을 사용할 수 잇고, 이 executor 스레드는 공유된다. executor 스레드는 한계가 정해지지 않아야(unbound) 하고 적절하게 세팅되어야 한다.
  - 캐시 사이즈는 캐시의 사이즈 또는 커넥션 갯수를 제한하는 것이 아니라 단순히 채널으 ㅣ갯수를 정의하는 것을 꼭 기억해야 한다.
  - 가장 기본적으로 사용되는 채널의 갯수는 10 개 이다. 1.6 버전부터는 디폴트 캐시 사이즈가 25 로 늘어났다.

<br>

**예제) PooledConnectionFactory 사용해보기**<br>

```java
@Bean
PooledChannelConnectionFactory pcf() throws Exception {
    ConnectionFactory rabbitConnectionFactory = new ConnectionFactory();
    rabbitConnectionFactory.setHost("localhost");
    PooledChannelConnectionFactory pcf = new PooledChannelConnectionFactory(rabbitConnectionFactory);
    pcf.setPoolConfigurer((pool, tx) -> {
        if (tx) {
            // configure the transactional pool
        }
        else {
            // configure the non-transactional pool
        }
    });
    return pcf;
}
```

<br>

**예제) CachingConnectionFactory 사용해보기**<br>

```java
CachingConnectionFactory connectionFactory = new CachingConnectionFactory("somehost");
connectionFactory.setUsername("guest");
connectionFactory.setPassword("guest");

Connection connection = connectionFactory.createConnection();
```

<br>

#### MessageListenerContainerConfiguration 내의 batchSize 설정

- [Message Listener Container Configuration](https://docs.spring.io/spring-amqp/docs/current/reference/html/#containerAttributes)

<br>

#### Resilience: Recovering from Errors and Broker Failures

전 직장에서 Resilience4j 기반의 CircuitBreker, FeignClient 그리고 여러가지 Spring Cloud 스택의 하모니를 구성했었는데, Spring AMQP(=오해 주의.래빗엠큐에 한정된게 아니다.) 에서도 Spring Cloud 에서 지원하는 다양한 기능을 사용할 수 있을지는 1차적으로 뭔가 만들어진 후에 Scale up 하면서 조사해 나가면 괜찮을 것 같다는 생각이 들었다.

- [Resilience : Recovering from Errors and Broker Failures](https://docs.spring.io/spring-amqp/docs/current/reference/html/#resilience-recovering-from-errors-and-broker-failures)

<br>

#### Retry with Batch Listeners

- [Retry with Batch Listeners](https://docs.spring.io/spring-amqp/docs/current/reference/html/#resilience-recovering-from-errors-and-broker-failures)

이것도 정리해야 한다.

<br>

